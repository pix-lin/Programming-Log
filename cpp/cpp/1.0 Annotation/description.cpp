// ===========================================================================
// 1. #pragma once
// 설명: (헤더 파일에서) 이 파일이 중복으로 include 되는 것을 막아줍니다.
//      C언어의 #ifndef ~ #endif 보다 훨씬 간단해서 실무에서 애용합니다.
// ===========================================================================
#pragma once 

#include <iostream>
#include <string>

// C++에서도 네임스페이스를 사용하여 이름 충돌을 방지합니다.
namespace GameDev {

    /// <summary>
    /// 플레이어의 기능을 정의한 클래스입니다. (XML 문서 주석은 C++에서도 작동합니다!)
    /// </summary>
    class Player
    {
    public:
        // ===========================================================================
        // 2. #pragma region : 코드 접기
        // 설명: C#의 #region과 똑같습니다. 단지 앞에 'pragma'라는 단어가 더 붙을 뿐입니다.
        //      마찬가지로 왼쪽의 [-] 버튼으로 접을 수 있습니다.
        // ===========================================================================
#pragma region [Data] 플레이어 스탯 (접기 가능)

        /// <summary>
        /// 플레이어의 현재 체력
        /// </summary>
        int hp = 100;

        /// <summary>
        /// 플레이어의 공격력
        /// </summary>
        int attackPower = 10;

#pragma endregion


        // ===========================================================================
        // 3. XML 문서 주석 태그 (C#과 동일하게 사용 가능)
        // 설명: Visual Studio C++에서도 이 태그를 쓰면 툴팁 설명이 뜹니다.
        // ===========================================================================

        /// <summary>
        /// [요약] 적을 공격하는 함수입니다.
        /// </summary>
        /// 
        /// <remarks>
        /// [상세 설명]<br/>
        /// C++에서도 'br' 태그로 줄바꿈을 할 수 있습니다.<br/>
        /// <b>주의:</b> 공격력이 0이면 아무 일도 일어나지 않습니다.
        /// </remarks>
        /// 
        /// <param name="targetName">[매개변수] 공격할 적의 이름</param>
        /// <param name="damage">[매개변수] 가할 데미지 양</param>
        /// 
        /// <returns>
        /// [반환값] 공격 성공 시 true, 실패 시 false
        /// </returns>
        bool Attack(std::string targetName, int damage)
        {
            if (damage <= 0) return false;

            std::cout << targetName << "에게 " << damage << " 데미지!" << std::endl;
            return true;
        }


        // ===========================================================================
        // 4. #ifdef, #endif : 조건부 컴파일
        // 설명: C#의 #if DEBUG와 같은 역할입니다.
        //      Visual Studio는 디버그 모드일 때 '_DEBUG'라는 매크로를 자동으로 만들어줍니다.
        // ===========================================================================

        void CheatKey()
        {
            // 배포용(Release) 모드에서는 이 코드가 기계어로 번역될 때 아예 삭제됩니다.
#ifdef _DEBUG
            std::cout << "[개발자 모드] 치트키 활성화: 무적 모드 ON" << std::endl;
            hp = 99999;
#endif
        }


        // ===========================================================================
        // 5. [[deprecated]] : C++ 스타일의 Attribute (속성)
        // 설명: C#의 [Obsolete]와 같습니다. 
        //      이 함수를 쓰면 컴파일러가 "이거 낡았으니 쓰지 마"라고 경고를 띄웁니다.
        // ===========================================================================

        [[deprecated("이 함수는 너무 낡았습니다. Attack() 함수를 대신 사용하세요.")]]
        void OldAttack()
        {
            // 옛날 방식의 공격 코드...
        }
    };
}